<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Physics Dots</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

class Dot {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.radius = 5;
    this.mass = 1;
    this.fixed = false;
  }

  applyForce(fx, fy) {
    if (this.fixed) return;
    this.vx += fx / this.mass;
    this.vy += fy / this.mass;
  }

  update() {
    if (this.fixed) return;
    this.vy += 0.1; // gravity
    this.vx *= 0.99; // damping
    this.vy *= 0.99;
    this.x += this.vx;
    this.y += this.vy;
  }

  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#0ff";
    ctx.fill();
  }
}

class Spring {
  constructor(a, b, length) {
    this.a = a;
    this.b = b;
    this.length = length;
    this.k = 0.1;
  }

  update() {
    const dx = this.b.x - this.a.x;
    const dy = this.b.y - this.a.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const force = this.k * (dist - this.length);
    const fx = (dx / dist) * force;
    const fy = (dy / dist) * force;

    this.a.applyForce(fx, fy);
    this.b.applyForce(-fx, -fy);
  }

  draw() {
    ctx.beginPath();
    ctx.moveTo(this.a.x, this.a.y);
    ctx.lineTo(this.b.x, this.b.y);
    ctx.strokeStyle = "#888";
    ctx.stroke();
  }
}

const dots = [];
const springs = [];

// Create a grid of dots
const cols = 10;
const rows = 10;
const spacing = 40;
for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    const dot = new Dot(100 + x * spacing, 100 + y * spacing);
    if (y === 0) dot.fixed = true; // top row fixed
    dots.push(dot);
  }
}

// Connect dots with springs
for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    const i = y * cols + x;
    if (x < cols - 1) {
      springs.push(new Spring(dots[i], dots[i + 1], spacing));
    }
    if (y < rows - 1) {
      springs.push(new Spring(dots[i], dots[i + cols], spacing));
    }
  }
}

let selectedDot = null;

canvas.addEventListener('mousedown', e => {
  const mx = e.clientX;
  const my = e.clientY;
  for (const dot of dots) {
    const dx = dot.x - mx;
    const dy = dot.y - my;
    if (dx * dx + dy * dy < dot.radius * dot.radius * 4) {
      selectedDot = dot;
      dot.fixed = true;
      break;
    }
  }
});

canvas.addEventListener('mousemove', e => {
  if (selectedDot) {
    selectedDot.x = e.clientX;
    selectedDot.y = e.clientY;
  }
});

canvas.addEventListener('mouseup', () => {
  if (selectedDot) {
    selectedDot.fixed = false;
    selectedDot = null;
  }
});

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const spring of springs) spring.update();
  for (const dot of dots) dot.update();
  for (const spring of springs) spring.draw();
  for (const dot of dots) dot.draw();
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
