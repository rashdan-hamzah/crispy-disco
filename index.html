<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Physics Dots with Collisions</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

class Dot {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.radius = 8;
    this.mass = 1;
    this.fixed = false;
  }

  applyForce(fx, fy) {
    if (this.fixed) return;
    this.vx += fx / this.mass;
    this.vy += fy / this.mass;
  }

  update() {
    if (this.fixed) return;
    this.vy += 0.2; // gravity
    this.vx *= 0.98; // damping
    this.vy *= 0.98;
    this.x += this.vx;
    this.y += this.vy;
  }

  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#0ff";
    ctx.fill();
  }

  checkCollision(other) {
    const dx = other.x - this.x;
    const dy = other.y - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minDist = this.radius + other.radius;
    if (dist < minDist && dist > 0) {
      const overlap = minDist - dist;
      const nx = dx / dist;
      const ny = dy / dist;

      if (!this.fixed) {
        this.x -= nx * overlap / 2;
        this.y -= ny * overlap / 2;
      }
      if (!other.fixed) {
        other.x += nx * overlap / 2;
        other.y += ny * overlap / 2;
      }

      // Simple elastic response
      const dvx = other.vx - this.vx;
      const dvy = other.vy - this.vy;
      const impact = dvx * nx + dvy * ny;
      const impulse = impact * 0.5;

      if (!this.fixed) {
        this.vx += impulse * nx;
        this.vy += impulse * ny;
      }
      if (!other.fixed) {
        other.vx -= impulse * nx;
        other.vy -= impulse * ny;
      }
    }
  }
}

class Spring {
  constructor(a, b, length) {
    this.a = a;
    this.b = b;
    this.length = length;
    this.k = 0.1;
  }

  update() {
    const dx = this.b.x - this.a.x;
    const dy = this.b.y - this.a.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const force = this.k * (dist - this.length);
    const fx = (dx / dist) * force;
    const fy = (dy / dist) * force;

    this.a.applyForce(fx, fy);
    this.b.applyForce(-fx, -fy);
  }

  draw() {
    ctx.beginPath();
    ctx.moveTo(this.a.x, this.a.y);
    ctx.lineTo(this.b.x, this.b.y);
    ctx.strokeStyle = "#888";
    ctx.stroke();
  }
}

const dots = [];
const springs = [];

const cols = 10;
const rows = 10;
const spacing = 40;
for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    const dot = new Dot(100 + x * spacing, 100 + y * spacing);
    if (y === 0) dot.fixed = true;
    dots.push(dot);
  }
}

for (let y = 0; y < rows; y++) {
  for (let x = 0; x < cols; x++) {
    const i = y * cols + x;
    if (x < cols - 1) {
      springs.push(new Spring(dots[i], dots[i + 1], spacing));
    }
    if (y < rows - 1) {
      springs.push(new Spring(dots[i], dots[i + cols], spacing));
    }
  }
}

let mouseDown = false;
let lastMouse = { x: 0, y: 0 };

canvas.addEventListener('mousedown', e => {
  mouseDown = true;
  lastMouse.x = e.clientX;
  lastMouse.y = e.clientY;
});

canvas.addEventListener('mousemove', e => {
  if (mouseDown) {
    const dx = e.clientX - lastMouse.x;
    const dy = e.clientY - lastMouse.y;
    for (const dot of dots) {
      const dist = Math.hypot(dot.x - e.clientX, dot.y - e.clientY);
      if (dist < 100) {
        const force = (100 - dist) * 0.05;
        const angle = Math.atan2(dot.y - e.clientY, dot.x - e.clientX);
        dot.applyForce(Math.cos(angle) * force, Math.sin(angle) * force);
      }
    }
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
  }
});

canvas.addEventListener('mouseup', () => {
  mouseDown = false;
});

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const spring of springs) spring.update();
  for (let i = 0; i < dots.length; i++) {
    for (let j = i + 1; j < dots.length; j++) {
      dots[i].checkCollision(dots[j]);
    }
  }
  for (const dot of dots) dot.update();
  for (const spring of springs) spring.draw();
  for (const dot of dots) dot.draw();
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
